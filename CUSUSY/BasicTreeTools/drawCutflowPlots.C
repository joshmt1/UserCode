//arguably stupid to redo the work that went into drawBasicPlot.C
//but I'm doing it anyway (lots of copy/paste)
//this code now replaces that code fully

//this code can be compiled:
//   .L drawCutflowPlots.C++

//drawNormalized() was used to produce plots of various distributions as generated by basicLoop::cutflowPlotter()
//work in progress: drawStack() to plot data/MC comparisons

//QCD and SingleTop need to be added with hadd

/* things that would be great to implement:
1. summary of overflow bins in last bins of stack (as Don's plots always have) -- done!
2. some sort of error bar indication on the stack (especially for QCD)
*/

#include "TROOT.h"
#include "TFile.h"
#include "TString.h"
#include "TStyle.h"
#include "TCanvas.h"
#include "TLegend.h"
#include "THStack.h"
#include "TH1.h"
#include "TLine.h"

#include "/afs/cern.ch/user/j/joshmt/root/util/HistHolder.h"
//i am using histHolder, but reimplementing a lot of stuff in PlotUtil,etc

#include <iostream>
#include <map>

//holds a list of the sample names (using same code as file name)
std::vector<TString> samples_;
std::map<TString, TFile*> files_;
std::map<TString, UInt_t> sampleColor_;
std::map<TString, TString> sampleLabel_;
std::map<TString, UInt_t> sampleMarkerStyle_;

TString loaded_=""; //bookkeeping

bool customrange_active=false;
double customrange_low=0;
double customrange_high=0;

double QCDscale_ = 1.0;

int rebin_=0;

bool logy_=false;
bool dostack_=false;
bool doleg_=true;
bool dodata_=true;

bool doVerticalLine_=false;
double verticalLinePosition_=0;

TCanvas* cnorm;
TLegend* leg;
THStack* thestack;

void enableVerticalLine(double position) {
  doVerticalLine_=true;
  verticalLinePosition_ =position;
}

void resetVerticalLine() {
  doVerticalLine_=false;
}

void setPlotRange(double low,double high) {
  customrange_low=low;
  customrange_high=high;
  customrange_active=true;
}

void resetPlotRange() {
  customrange_active=false;
}

void setQCDScale(double scale) {
  QCDscale_=scale;
}

void setLogY(bool dolog) {
  logy_=dolog;
}

void setStackMode(bool dostack) {
  dostack_=dostack;
}

void doData(bool dodata) {
  dodata_=dodata;
}

void setRebin(int rebin) {
  rebin_=rebin;
}

void resetRebin() {
  setRebin(0);
}

void drawLegend(bool doleg) {
  doleg_=doleg;
}

//note that this function is adding yet another manipulation to the histogram that must only be done once!
//so it adds yet another reason why the same histogram cannot be plotted twice in one ROOT session!
void addOverflowBin(TH1D* theHist) {
  //the tricky part here is that we may have set a custom plot range.
  //in this case the overflow isn't the simple content of Nbins+1
  //I don't know if there is any clever way to get it....

  int lastVisibleBin = customrange_active ? theHist->FindBin(customrange_high) : theHist->GetNbinsX();
  //  cout<<theHist<<"  "<<lastVisibleBin<<"\t";

  //in case there is no custom range, the code should just add the overflow bin to the last bin of the histo
  double lastBinContent = theHist->GetBinContent(lastVisibleBin);
  double lastBinError = pow(theHist->GetBinError(lastVisibleBin),2); //square in prep for addition

  cout<<"Overflow addition: "<<lastBinContent<<" +/- "<<sqrt(lastBinError)<<" --> ";

  //now loop over the bins that aren't being shown at the moment (including the overflow bin)
  for (int ibin = lastVisibleBin+1; ibin <= 1 + theHist->GetNbinsX() ; ++ibin) {
    lastBinContent += theHist->GetBinContent( ibin);
    lastBinError += pow(theHist->GetBinError( ibin),2);
  }
  lastBinError = sqrt(lastBinError);

  theHist->SetBinContent(lastVisibleBin,lastBinContent);
  theHist->SetBinError(lastVisibleBin,lastBinError);
  cout<<lastBinContent<<" +/- "<<lastBinError<<endl;
}

void drawVerticalLine() {

  //this is a fine example of ROOT idiocy
  TVirtualPad* thePad = cnorm->GetPad(0);
  double xmin,ymin,xmax,ymax;
  thePad->GetRangeAxis(xmin,ymin,xmax,ymax);
  //for academic interest, can get the same numbers using e.g. thePad->GetUymax()
  if (logy_) {
    ymax = pow(10, ymax);
    ymin = pow(10, ymin);
  }
  TLine theLine(verticalLinePosition_,ymin,verticalLinePosition_,ymax);
  theLine.SetLineColor(kBlue);
  theLine.SetLineWidth(3);

  theLine.DrawClone();

}

TFile* fdata=0;
TH1D* hdata=0;
void loadSamples(TString filestub) {
  if (filestub == loaded_) return;
  else if (loaded_ != "") {cout<<"quit root and try again"<<endl; return;}
  loaded_=filestub;
  const TString cutdesc = "Baseline0_PF_pfMEThigh_PFLep0e0mu_minDP_MuonCleaning";

  samples_.push_back("QCD");
  samples_.push_back("TTbarJets");
  samples_.push_back("SingleTop");
  samples_.push_back("WJets");
  samples_.push_back("ZJets");
  samples_.push_back("Zinvisible");
  samples_.push_back("LM13");

  sampleColor_["LM13"] = kGray; //borrowed from a different sample
  sampleColor_["QCD"] = kYellow;
  sampleColor_["TTbarJets"]=kRed+1;
  sampleColor_["SingleTop"] = kMagenta;
  sampleColor_["WJets"] = kGreen-3;
  sampleColor_["ZJets"] = kAzure-2;
  sampleColor_["Zinvisible"] = kOrange-3;

  sampleLabel_["LM13"] = "LM13";
  sampleLabel_["QCD"] = "QCD";
  sampleLabel_["TTbarJets"]="t#bar{t}";
  sampleLabel_["SingleTop"] = "Single-Top";
  sampleLabel_["WJets"] = "W#rightarrowl#nu";
  sampleLabel_["ZJets"] = "Z/#gamma*#rightarrowl^{+}l^{-}";
  sampleLabel_["Zinvisible"] = "Z#rightarrow#nu#nu";

  sampleMarkerStyle_["LM13"] = kFullStar;
  sampleMarkerStyle_["QCD"] = kFullCircle;
  sampleMarkerStyle_["TTbarJets"]= kFullSquare;
  sampleMarkerStyle_["SingleTop"] = kOpenSquare;
  sampleMarkerStyle_["WJets"] = kMultiply;
  sampleMarkerStyle_["ZJets"] = kFullTriangleUp;
  sampleMarkerStyle_["Zinvisible"] = kFullTriangleDown;

  for (unsigned int isample=0; isample<samples_.size(); isample++) {
    TString fname=filestub; fname+=".";
    fname+=cutdesc;
    fname+=".";
    fname+=samples_[isample];
    fname+=".root";
    files_[samples_[isample]] = new TFile(fname);
    if (files_[samples_[isample]]->IsZombie() ) cout<<"file error with "<<samples_[isample]<<endl;
    else     cout<<"Added sample: "<<samples_[isample]<<endl;
  }

  //load data file too
  TString dname=filestub; dname+=".";
  dname+=cutdesc;
  dname+=".data.root";
  if (dname.Contains("_NoTrigger"))   dname.ReplaceAll("_NoTrigger","");
  if (dostack_ && dodata_) {
    fdata = new TFile(dname);
    if (fdata->IsZombie()) cout<<"Problem with data file! "<<dname<<endl;
  }

}

//the name of this function is now a misnomer, since it draws either normalized or stacked
void drawNormalized(const TString hname, const TString xtitle, const TString ytitle)
{

  gROOT->SetStyle("CMS");

  TString scaleAppendToFilename="";

  if (dostack_)  loadSamples("Nminus1plots");
  else   loadSamples("cutflowPlots");
  
  cnorm= new TCanvas("cnorm","normalized",600,400);
  cnorm->cd()->SetRightMargin(0.04);

  if (logy_) cnorm->SetLogy();

  leg = new TLegend(0.696, 0.35, 0.94, 0.92);
  leg->SetBorderSize(0);

  //leg->SetFillColor(0);
  //leg->SetLineColor(1);
  leg->SetLineStyle(0);
  leg->SetTextFont(42);
  leg->SetFillStyle(0);

  if (dostack_)  thestack = new THStack("thestack","--");

  //first load the desired histogram from each file
  HistHolder hh;
  TString opt="hist e";
  for (unsigned int isample=0; isample<samples_.size(); isample++) {
    cout <<samples_[isample]<<endl;
    hh.load(hname,files_[samples_[isample]]);
    hh.find(hname,files_[samples_[isample]])->SetXTitle(xtitle);
    hh.find(hname,files_[samples_[isample]])->SetYTitle(ytitle);

    //hard-coded selection of QCD for rescaling
    if (samples_[isample] == "QCD") {
      //if you don't want rescaling, then use the default QCDscale_ of 1
      hh.find(hname,files_[samples_[isample]])->Scale(QCDscale_);
      if (QCDscale_ != 1 && dostack_) {
	TString qcdLabel;
	qcdLabel.Form("%s%.1f","QCD #times ",QCDscale_);
	sampleLabel_["QCD"] = qcdLabel;
	scaleAppendToFilename.Form("-S%.1f",QCDscale_);
	//once again, pdflatex is stupid and so we have to get rid of dots in the filename
	scaleAppendToFilename.ReplaceAll(".","_");
      }
      else {
	scaleAppendToFilename="";
	sampleLabel_["QCD"] = "QCD";
      }
    }

    if (customrange_active) {
      hh.find(hname,files_[samples_[isample]])->GetXaxis()->SetRangeUser(customrange_low,customrange_high);
    }
    if (rebin_!=0)    hh.find(hname,files_[samples_[isample]])->Rebin(rebin_);

    //better do these bin-based manipulations after the rebinning!
    addOverflowBin(  hh.find(hname,files_[samples_[isample]]) ); //manipulates the TH1D provided via the pointer!

    //cout<<"

    if (!dostack_) {
      //set line color instead of fill color for this type of plot
      hh.find(hname,files_[samples_[isample]])->SetLineColor(sampleColor_[samples_[isample]]);
      hh.find(hname,files_[samples_[isample]])->SetMarkerStyle(sampleMarkerStyle_[samples_[isample]]);
      hh.find(hname,files_[samples_[isample]])->SetMarkerColor(sampleColor_[samples_[isample]]);
      
      //ad hoc additions
      hh.find(hname,files_[samples_[isample]])->SetLineWidth(2);
      hh.find(hname,files_[samples_[isample]])->SetMarkerColor(sampleColor_[samples_[isample]]);
    }
    else {
      hh.find(hname,files_[samples_[isample]])->SetFillColor(sampleColor_[samples_[isample]]);
    }

    leg->AddEntry( hh.find(hname,files_[samples_[isample]]), sampleLabel_[samples_[isample]]);

    if (dostack_) {
      thestack->Add( hh.find(hname,files_[samples_[isample]]) );
    }
    else {
      hh.find(hname,files_[samples_[isample]])->Draw(opt);
      if (!opt.Contains("same")) opt+=" same";
    }
  }


  if (!dostack_) {
    hh.normalize(); //normalize all histos to 1
    hh.SetMaximum( hh.GetMaximum()*1.05);
  }
  else {
    thestack->Draw("hist");
    thestack->GetHistogram()->GetXaxis()->SetTitle(xtitle);
    thestack->GetHistogram()->GetYaxis()->SetTitle(ytitle);
    if (customrange_active) {
      thestack->GetHistogram()->GetXaxis()->SetRangeUser(customrange_low,customrange_high);
    }

    if (doVerticalLine_) drawVerticalLine(); //i want to draw the data last

    if (dodata_) {
      hdata = (TH1D*) fdata->Get(hname);
      if (hdata == 0) cout<<"Problem with data histogram!"<<endl;
      hdata->UseCurrentStyle();
      hdata->SetMarkerColor(kBlack);
      hdata->SetLineWidth(2);
      hdata->SetMarkerStyle(kFullCircle);
      hdata->SetMarkerSize(1);
      if (rebin_!=0)  hdata->Rebin(rebin_);
      addOverflowBin(hdata); // manipulates the histogram!
      hdata->Draw("SAME");
      cout<<hdata->GetMaximum()<<"\t"<<thestack->GetMaximum()<<endl;
      if (hdata->GetMaximum() > thestack->GetMaximum()) {
	thestack->SetMaximum( hdata->GetMaximum());
      }
    }
  }

  if (doleg_)  leg->Draw();


  TString savename = hname;
  if (logy_) savename += "-logY";
  savename += scaleAppendToFilename;

  if (!dostack_)    savename += "-drawNormalized";
  else savename += "-drawStack";

  //amazingly, \includegraphics cannot handle an extra dot in the filename. so avoid it.
  cnorm->SaveAs(savename+".eps"); //for me
  //  cnorm->Print(savename+".C");    //for formal purposes
  cnorm->SaveAs(savename+".pdf"); //for pdftex
  cnorm->SaveAs(savename+".png"); //for twiki


}

//the functions below are not really meant to be run
//they are just usage examples

//the way this code is written right now,
//one must be very careful when making multiple plots in the same ROOT session
//if one plots the same quantity multiple times in the same session, the Rebin option will be applied each time
//also, the QCD scale factor will be applied each time!
//FIXME these problems should really be fixed by refactoring the code somehow, but for now i will have to live with it

void plotStuff()
{
  //this first one is not so informative because of HT=0 events
  drawNormalized("H_HT_cutInclusive","HT [GeV]","Arbitrary units");
  drawNormalized("H_NJets_cutHT","# of jets","Arbitrary units");

  setPlotRange(0,5);
  drawNormalized("H_NElectrons_cut3Jets","# of electrons","Arbitrary units");
  drawNormalized("H_NMuons_cut3Jets","# of muons","Arbitrary units");

  resetPlotRange();
  drawNormalized("H_MET_cutMuVeto","E^{miss}_{T} [GeV]","Arbitrary units");

  setRebin(2);
  drawNormalized("H_minDeltaPhi_cutMET","#Delta #phi_{min}","Arbitrary units");
  resetRebin();

  setPlotRange(0,5);
  drawNormalized("H_NBJets_cutMET","# of b-tagged jets","Arbitrary units");
  drawNormalized("H_NBJets_cutDeltaPhi","# of b-tagged jets","Arbitrary units");

}

void plotOtherStuff()
{

  setStackMode(true);

  setPlotRange(40,260);
  setLogY(true);
  drawNormalized("H_MET","MET [GeV]","Events");

  setQCDScale(2.8); //add in the scale factor!
  drawNormalized("H_MET_ge1b","MET [GeV]","Events");
  drawNormalized("H_MET_ge2b","MET [GeV]","Events");

  //
  setStackMode(true); //once per session
  //
  setPlotRange(150,1200);
  setRebin(10);
  drawNormalized("H_HT","HT (GeV)","Events");

  setPlotRange(0,8);
  resetRebin();
  drawNormalized("Hnjets","# of jets","Events");
  drawNormalized("Hnjets_ge1b","# of jets","Events");
  drawNormalized("Hnjets_ge2b","# of jets","Events");

  setPlotRange(0,3);
  drawNormalized("HnElectrons","# of electrons","Events");
  drawNormalized("HnElectrons_ge1b","# of electrons","Events");
  drawNormalized("HnElectrons_ge2b","# of electrons","Events");

  drawNormalized("HnMuons","# of muons","Events");
  drawNormalized("HnMuons_ge1b","# of muons","Events");
  drawNormalized("HnMuons_ge2b","# of muons","Events");

  setPlotRange(0,260);
  setLogY(true);
  drawNormalized("H_MET","E_{T}^{miss}","Events");
  drawNormalized("H_MET_ge1b","E_{T}^{miss}","Events");
  drawNormalized("H_MET_ge2b","E_{T}^{miss}","Events");

  setLogY(false);
  resetPlotRange();
  setRebin(10);
  drawNormalized("H_METphi","#phi of E_{T}^{miss}","Events");


  setRebin(4);
  setLogY(true);
  drawLegend(false);
  drawNormalized("HminDeltaPhiMETj","min(#Delta#phi[ jets 1..3, E_{T}^{miss} ] )","Events");

  drawNormalized("HminDeltaPhiMETj_ge1b","min(#Delta#phi[ jets 1..3, E_{T}^{miss} ] )","Events");
  setLogY(false);
  drawLegend(true);
  drawNormalized("HminDeltaPhiMETj_ge1b","min(#Delta#phi[ jets 1..3, E_{T}^{miss} ] )","Events");

  setPlotRange(0,4);
  resetRebin();
  drawNormalized("Hnbjets","# of b-tagged jets","Events");


  resetPlotRange();
  setRebin(4);
  drawNormalized("Hjetpt1","p_{T} of lead jet","Events");
  drawNormalized("Hjetpt1_ge1b","p_{T} of lead jet","Events");
  drawNormalized("Hjetpt1_ge2b","p_{T} of lead jet","Events");

  drawNormalized("Hjetphi1","#phi of lead jet","Events");
  drawNormalized("Hjetphi1_ge1b","#phi of lead jet","Events");
  drawNormalized("Hjetphi1_ge2b","#phi of lead jet","Events"); //why are 2 events at the same phi?

  drawNormalized("Hjeteta1","#eta of lead jet","Events");
  drawNormalized("Hjeteta1_ge1b","#eta of lead jet","Events");
  drawNormalized("Hjeteta1_ge2b","#eta of lead jet","Events");

  drawNormalized("Hbjetpt1_ge1b","p_{T} of lead b-tagged jet","Events");
  drawNormalized("Hbjetpt1_ge2b","p_{T} of lead b-tagged jet","Events");

}

/*
constructing this one carefully so that running it once through really will produce a complete and valid set of plots
(i.e. keeping in mind the bugs I already discussed)
This is more or less how I generated plots for the AN
*/
void plotWithScale() {
  // .L drawCutflowPlots.C++                                                                          

  //setting for the whole session
  setStackMode(true);

  // == starting here, draw with the high MET region files ===

  //MET (first draw without scale factor)
  setPlotRange(0,260);
  setLogY(true);
  drawNormalized("H_MET","E_{T}^{miss} [GeV]","Events");
  drawNormalized("H_MET_eq1b","E_{T}^{miss} [GeV]","Events");
  drawNormalized("H_MET_ge1b","E_{T}^{miss} [GeV]","Events");
  drawNormalized("H_MET_ge2b","E_{T}^{miss} [GeV]","Events");

  resetPlotRange(); 
  setLogY(false);
  setRebin(4);
  drawNormalized("HminDeltaPhiMETj_ge1b","min(#Delta#phi[ jets 1..3, E_{T}^{miss} ] )","Events");
  drawNormalized("HminDeltaPhiMETj_ge2b","min(#Delta#phi[ jets 1..3, E_{T}^{miss} ] )","Events");
  drawNormalized("HminDeltaPhiMETj_eq1b","min(#Delta#phi[ jets 1..3, E_{T}^{miss} ] )","Events");


  setQCDScale(2.8);

  //don't bother with these at the moment

  //MET
//   setPlotRange(0,260);
//   setLogY(true);
//   enableVerticalLine(150);
//   drawNormalized("H_MET_ge1b","E_{T}^{miss} [GeV]","Events");
//   drawNormalized("H_MET_ge2b","E_{T}^{miss} [GeV]","Events");

//   //minDeltaPhi
//   enableVerticalLine(0.3);
//   resetPlotRange(); 
//   setLogY(false);
//   setRebin(4);
//   drawNormalized("HminDeltaPhiMETj_ge1b","min(#Delta#phi[ jets 1..3, E_{T}^{miss} ] )","Events");
//   drawNormalized("HminDeltaPhiMETj_ge2b","min(#Delta#phi[ jets 1..3, E_{T}^{miss} ] )","Events");

  // == here, start over and draw with the medhigh MET region files ===

  //HT
  resetVerticalLine();
  setPlotRange(150,1200);
  setRebin(25); //gives 100 GeV wide bins
  drawNormalized("H_HT_ge1b","H_{T} (GeV)","Events");
  drawNormalized("H_HT_ge2b","H_{T} (GeV)","Events");
  drawNormalized("H_HT_eq1b","H_{T} (GeV)","Events");

  //n jets
  setPlotRange(0,8);
  resetRebin();
  drawNormalized("Hnjets_ge1b","Jet multiplicity","Events");
  drawNormalized("Hnjets_ge2b","Jet multiplicity","Events");
  drawNormalized("Hnjets_eq1b","Jet multiplicity","Events");

  //n b jets
  setPlotRange(0,4);
  drawNormalized("Hnbjets","Number of b-tagged jets","Events");

  //n leptons
  setPlotRange(0,3);
  //  drawNormalized("HnElectrons","Number of electrons","Events");
  drawNormalized("HnElectrons_ge1b","Number of electrons","Events");
  drawNormalized("HnElectrons_ge2b","Number of electrons","Events");
  drawNormalized("HnElectrons_eq1b","Number of electrons","Events");

  //  drawNormalized("HnMuons","Number of muons","Events");
  drawNormalized("HnMuons_ge1b","Number of muons","Events");
  drawNormalized("HnMuons_ge2b","Number of muons","Events");
  drawNormalized("HnMuons_eq1b","Number of muons","Events");

  //jet pT
  resetPlotRange();
  setRebin(5); //100 bins originally
  //  drawNormalized("Hjetpt1","p_{T} of lead jet","Events");
  drawNormalized("Hjetpt1_ge1b","p_{T} of lead jet","Events");
  drawNormalized("Hjetpt1_ge2b","p_{T} of lead jet","Events");
  drawNormalized("Hjetpt1_eq1b","p_{T} of lead jet","Events");

  //b jet pT
  //same rebin factor
  drawNormalized("Hbjetpt1_ge1b","p_{T} of lead b-tagged jet","Events");
  drawNormalized("Hbjetpt1_ge2b","p_{T} of lead b-tagged jet","Events");
  drawNormalized("Hbjetpt1_eq1b","p_{T} of lead b-tagged jet","Events");

  resetRebin(); //cleanup

}

void morePlots() {
  // .L drawCutflowPlots.C++                                                                          

  doData(false);
  //setting for the whole session
  setStackMode(true);

  setLogY(true);

  drawNormalized("HdeltaPhiMPTMET_MET0","#Delta #phi (MPT,MET) for all MET, no minDP cut","Events");
  drawNormalized("HdeltaPhiMPTMET_MET150","#Delta #phi (MPT,MET) for MET>150, no minDP cut","Events");

  setLogY(false);
  drawNormalized("HdeltaPhiMPTMET_MET0","#Delta #phi (MPT,MET) for all MET, no minDP cut","Events");

}

//a new and rather independent set of code
void plotQCD() {
  // .L drawCutflowPlots.C++                                                                          

  /*
  loadSamples("Nminus1plots");

  TH1D* ratio_Over = (TH1D*) files_["QCD"]->Get("HminDeltaPhiRatio_Over");
  TH1D* ratio_Under = (TH1D*) files_["QCD"]->Get("HminDeltaPhiRatio_Under");
  TH1D* ratio_Close = (TH1D*) files_["QCD"]->Get("HminDeltaPhiRatio_Close");
  */

  TFile f("Nminus1plots.Baseline0_PF_pfMEThigh_PFLep0e0mu_minDP_MuonCleaning.QCD.root");
  TH1D* ratio_Over = (TH1D*) f.Get("HminDeltaPhiRatio_Over");
  TH1D* ratio_Under = (TH1D*) f.Get("HminDeltaPhiRatio_Under");
  TH1D* ratio_Close = (TH1D*) f.Get("HminDeltaPhiRatio_Close");

  gStyle->SetOptStat(0);

  TCanvas * cratio = new TCanvas("cratio","ratio",600,400);
  cratio->SetLogy(); //for some reason this had no effect....

  ratio_Close->SetLineColor(kGreen); //  ratio_Close->SetMarkerStyle();
  ratio_Under->SetLineColor(kRed);
  ratio_Over->SetLineColor(kBlue);

  ratio_Close->SetXTitle("MET (GeV)");
  ratio_Close->SetYTitle("r");
  ratio_Close->SetTitle("");

  TLegend theleg(0.15,0.55,0.5,0.85);
  theleg.AddEntry(ratio_Over,"(reco - gen pT) > 50 GeV");
  theleg.AddEntry(ratio_Under,"(reco - gen pT) < -50 GeV");
  theleg.AddEntry(ratio_Close,"(reco - gen pT) within 50 GeV ");

  ratio_Close->Draw();

  theleg.SetBorderSize(0);

  //theleg.SetFillColor(0);
  //theleg.SetLineColor(1);
  theleg.SetLineStyle(0);
  theleg.SetTextFont(42);
  theleg.SetFillStyle(0);

  theleg.Draw();

  ratio_Under->Draw("same");
  ratio_Over->Draw("same");

}

void MPTMET() {

  TFile f("Nminus1plots.Baseline0_PF_pfMEThigh_PFLep0e0mu_minDP_MuonCleaning.QCD.root");
  TH1D* pass_h = (TH1D*) f.Get("HminDeltaPhiPass_hMPTMET");
  TH1D* fail_h = (TH1D*) f.Get("HminDeltaPhiFail_hMPTMET");

  TH1D* pass_l = (TH1D*) f.Get("HminDeltaPhiPass_lMPTMET");
  TH1D* fail_l = (TH1D*) f.Get("HminDeltaPhiFail_lMPTMET");

  const int rebin=4;
  pass_h->Rebin(rebin);
  fail_h->Rebin(rebin);

  pass_l->Rebin(rebin);
  fail_l->Rebin(rebin);

  TH1D* ratio_h = new TH1D("ratio_h","r(MET) high",pass_h->GetNbinsX(),pass_h->GetXaxis()->GetXmin(),pass_h->GetXaxis()->GetXmax());
  TH1D* ratio_l = new TH1D("ratio_l","r(MET) low",pass_h->GetNbinsX(),pass_h->GetXaxis()->GetXmin(),pass_h->GetXaxis()->GetXmax());

  ratio_h->Divide(pass_h,fail_h);
  ratio_l->Divide(pass_l,fail_l);

  TH1D* Hhl = new TH1D("Hhl","double ratio",pass_h->GetNbinsX(),pass_h->GetXaxis()->GetXmin(),pass_h->GetXaxis()->GetXmax());
   Hhl->Divide(ratio_h,ratio_l);

}
